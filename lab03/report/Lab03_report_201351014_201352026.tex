\documentclass{sem5}
\institutename{Indian Institute of Information Technology, Vadodara}
\author{Dilip Puri}
\idt{201351014}
%\team{teamname}
\collab{\textbf{Collaborator} - Hemant Kumar(201352026)}

\coursename{Parallel Programming}
\ccode{\begin{small}CS403\end{small}}
\profname{Prof. Reshmi Mitra}

\type{Lab}
\typeid{03}
\submissiondate{\today}%dd/mm/yyyy
\deadline{Aug 26, 4:00 PM}%dd/mm/yyyy @hh:mm pm/am
\problemset{OpenMP(Open Multi-Processing)}

\begin{document}
\begin{enumerate}
\item Familiarize yourself with the OpenMP code given in this handout.
\begin{figure}[!htp]
\centering
%\includegraphics[scale=.4]{../barrier.png}\\
%\includegraphics[scale=.4]{../rwlock.png}
\end{figure}
\item Using the command in the section on ``How to measure time for a block of C-code", find the time required in the thread function call in the previous lab assignment.\\

\item Write a C-code using OpenMP threads to create an unbalanced load using sleep command and omp$\_$hello.c. The sample sleep times are given below:
\begin{enumerate}
\item thread-1: 10 sec, thread-2: 5 sec, thread-3: 20 sec, thread-4: 30 sec.
\item Measure the total time taken for the complete execution of code with and without the additional sleep command.
\end{enumerate}

\item Write a threaded code using OpenMP on matrix multiplication:
\begin{enumerate}
\item Take overall execution time measurement using time command for different application size and thread count for the serial and parallel code.
\begin{center}
\begin{tabular}{|c|c|c|c|c|}
\hline
& p=1 & p=2 & p=4 & p=8\\
\hline
Vector Length = 100,000 & 0.0095 & 0.0124 & 0.0121 & 0.0102 \\
\hline
Vector Length = 200,000 & 0.014 & 0.0166 & 0.0121 & 0.0163 \\
\hline
\end{tabular}

$Speedup = \frac{Execution Time(p)}{Execution Time(serial code)}$\\
\vspace*{1cm}
\begin{tabular}{|c|c|c|c|}
\hline
 & p=2 & p=4 & p=8\\
\hline
Vector Length = 100,000 & 1.31 & 1.27 & 1.07 \\
\hline
Vector Length = 200,000 & 1.19 & 1.26 & 1.16 \\
\hline
\end{tabular}

\end{center}
\item Observe \texttt{gnome-system-monitor} output as your fire up different thread counts.

\item Use the overall execution time measurements to plot and comment upon the speed-up. Verify that:
\begin{enumerate}
\item Parallel execution time is more compared to the serial time when the application size is small.
\item For large application size, initially the speedup increases as you increase the number of threads. However, for very large number of threads (e.g. 64 threads) your performance becomes much worse w.r.t. serial code and lower thread count.

\end{enumerate}
\end{enumerate}

\item \textbf{Multi-access threaded queue - using OpenMP}
Implement a multi-access threaded queue with multiple threads inserting and multiple threads extracting from the queue. Use mutex-locks to synchronize access to this queue. Document the time for 1000 insertion and 1000 extractions each with 4 insertion threads (producers) and 4 extraction threads (consumers).(Buffer size = 250)
\end{enumerate}

\begin{itemize}
\item[3] Multi-access threaded queue
\begin{enumerate}
\item Implement a multi-access threaded queue with multiple threads inserting and multiple threads extracting from the queue. Use mutex-locks to synchronize access to this queue. Document the time for 1000 insertion and 1000 extractions each with 4 insertion threads (producers) and 4 extraction threads (consumers).

\item Repeat above problem with condition variables (in addition to mutex locks). Document the time for the same test case as above. Comment on the difference in the times.

\end{enumerate}
\end{itemize}
\end{document}