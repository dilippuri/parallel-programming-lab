\documentclass{sem5}

\institutename{Indian Institute of Information Technology, Vadodara}
\author{Dilip Puri}
\idt{201351014}
%\team{teamname}
\collab{\textbf{Collaborator} - Hemant Kumar(201352026)}

\coursename{Parallel Programming}
\ccode{\begin{small}CS403\end{small}}
\profname{Prof. Reshmi Mitra}

\type{Lab}
\typeid{01}
\submissiondate{\today}%dd/mm/yyyy
\deadline{Due Aug 15, 4:00 PM}%dd/mm/yyyy @hh:mm pm/am
\problemset{Peak Performance, Basic Linux commands, Introduction to POSIX threads}

\begin{document}
\section*{Peak Performance}
\begin{enumerate}
\item[Problem 1] Consider a memory system with a level 1 cache of 32 KB and DRAM of 512 MB with the processor operating at 1 GHz. The latency to L1 cache is 1 cycle and the latency to DRAM is 100 cycles. In each memory cycle, the processor fetches four words (cache line size is 4 words). What is the peak achievable performance of a dot product of two vectors?
\lstset{language=C}
\begin{lstlisting}[frame=single]
/* dot product loop */
for (i = 0; i < dim; i++)
	dot_prod += a[i] * b[i];
-----------------------------------------------------
Answer:

	Main memory = 512 MB
	Cache = 32 KB
	Processor operating at 1 GHz
	L1 cache latency = 1 cycle
	L2 or main memory latency = 100 cycle
	In 1 memory cycle processor fetch no. of words = 4
	cache line size = 4 words
	Peak Performance = no. of maximum floating pt(arithmatic) operations
	so,
		
			1 cycle takes 1/(1x10^9) seconds.
			One access to memory takes 100/(1x10^9) seconds. = 100ns.
			Performance = 4 FLOPS/(100/(1x10^9)) = 40 MFLOPS.
			
															-
\end{lstlisting}
\item[Problem 2] Now consider the problem of multiplying a dense matrix with a vector using a two-loop dot-product formulation. The matrix is of dimension 4K x 4K. (Each row of the matrix takes 16 KB of storage.) What is the peak achievable performance of this technique using a two-loop dot-product based matrix-vector product?
\lstset{language=C}
\begin{lstlisting}[frame=single]
/* matrix-vector product loop */
for (i = 0; i < dim; i++)
	for (j = 0; j < dim; j++)
		c[i] += a[i][j] * b[i];
-----------------------------------------------------
Answer:

	Main memory = 512 MB
	Cache = 32 KB
	Dimension of matrix = 4K(16 KB storage)
			1 cycle takes 1/(1x10^9) seconds.
			One access to memory takes 100/(1x10^9) seconds. = 100ns.
			Performance = 8 FLOPS/(100/(1x10^9)) = 80 MFLOPS.
															-
\end{lstlisting}
\end{enumerate}
\section*{Linux commands}
\lstset{language=C}
\begin{lstlisting}[frame=single]
$top
\end{lstlisting}
\begin{figure}[htp]
\centering
\includegraphics[scale=.35]{1.png}
\caption{top: provides dynamic real-time view of individual jobs running on the system}
\end{figure}
\begin{lstlisting}[frame=single]
$gnome-system-monitor
\end{lstlisting}
\begin{figure}[!htp]
\centering
\includegraphics[scale=.4]{2.png}
\caption{gnome-system-monitor: shows which programs are running and how much processor time, memory, and disk space are being used. This gives an overall system view whereas the ``top" instruction represents a detailed perspective}
\end{figure}
\begin{lstlisting}[frame=single]
$lscpu
We can also get the same information from $cat /proc/cpuinfo 
==================================
Architecture:          x86_64
CPU op-mode(s):        32-bit, 64-bit
Byte Order:            Little Endian
CPU(s):                2
On-line CPU(s) list:   0,1
Thread(s) per core:    1
Core(s) per socket:    2
Socket(s):             1
NUMA node(s):          1
Vendor ID:             AuthenticAMD
CPU family:            18
Model:                 1
Stepping:              0
CPU MHz:               800.000
BogoMIPS:              4392.08
Virtualization:        AMD-V
L1d cache:             64K
L1i cache:             64K
L2 cache:              1024K
NUMA node0 CPU(s):     0,1
dilip@dilip-notebook-pc:~$ lscpu
Architecture:          x86_64
CPU op-mode(s):        32-bit, 64-bit
Byte Order:            Little Endian
CPU(s):                2
On-line CPU(s) list:   0,1
Thread(s) per core:    1
Core(s) per socket:    2
Socket(s):             1
NUMA node(s):          1
Vendor ID:             AuthenticAMD
CPU family:            18
Model:                 1
Stepping:              0
CPU MHz:               800.000
BogoMIPS:              4392.08
Virtualization:        AMD-V
L1d cache:             64K
L1i cache:             64K
L2 cache:              1024K
NUMA node0 CPU(s):     0,1

\end{lstlisting}
\begin{lstlisting}[frame=single]
$time ./a.out
\end{lstlisting}
\begin{figure}[!htp]
\centering
\includegraphics[scale=.4]{3.png}
\caption{time: Get total program execution time in the shell}
\end{figure}
\section*{Lab Problems}
\begin{enumerate}
\item Familiarize yourself with the Linux commands and POSIX thread code given in this handout.
\item Solutions for Problems 1-2 on peak performance.
\item Using the basic Linux commands find the cache size, bandwidth number of processors on your system.
\item Write a C-code using POSIX threads to create an unbalanced load using sleep command and hello.c. The sample sleep times are given below:
\begin{enumerate}
\item thread-1: 1000 sec, thread-2: 5000 sec, thread-3: 20 sec, thread-4: 1200 sec.
\item Measure the total time taken for the complete execution of code with and without the additional sleep command.\\
Hint: You will require to include unistd.h for successful compilation.
\end{enumerate}
\item Write a C-code using POSIX threads about matrix multiplication.
\begin{enumerate}
\item Take overall execution time measurement using time command for different application size and thread count for the serial and parallel code.
\item Observe gnome-system-monitor output as your fire up different thread counts.
\item Use the overall execution time measurements to plot and comment upon the speed-up.
\begin{figure}[!htp]
\centering
\includegraphics[scale=.5]{result.png}
\end{figure}
\end{enumerate}
\end{enumerate}
\end{document}